"""
PUT endpoint
The application presented in the following example implements two endpoints:
GET /, which returns an integer stored in the global variable VALUE, and PUT /,
which allows this variable to be incremented by 1. The ETag is generated by
incrementing a different counter named ETAG, and it is incremented randomly each
time the value is changed.

To run the following application, run the command python flask-etag-put.py.
It will start the flask-based HTTP server. Then, open another terminal, and
contact the server using command http HEAD http://127.0.0.1:5000.
Run http PUT http://127.0.0.1:5000 VALUE="new_val" to update the VALUE variable.
"""
import random
import unittest
import flask
from werkzeug import exceptions

app = flask.Flask(__name__)


class NotModified(exceptions.HTTPException):
    code = 304


ETAG = random.randint(1000, 5000)
VALUE = "hello"


def check_etag(exception_class):
    global ETAG

    if_match = flask.request.headers.get("If-Match")
    if if_match is not None and if_match != str(ETAG):
        raise exception_class

    if_none_match = flask.request.headers.get("If-None-Match")
    if if_none_match is not None and if_none_match == str(ETAG):
        raise exception_class


@app.route("/", methods=["GET"])
def get_index():
    check_etag(NotModified)
    return flask.Response(VALUE, headers={"ETag": ETAG})


@app.route("/", methods=["PUT"])
def put_index():
    global ETAG, VALUE

    check_etag(exceptions.PreconditionFailed)

    ETAG += random.randint(3, 9)
    VALUE = flask.request.data
    return flask.Response(VALUE, headers={"ETag": ETAG})


class TestApp(unittest.TestCase):
    def test_put_index_if_match_positive(self):
        test_app = app.test_client()
        resp = test_app.get()
        etag = resp.headers["ETag"]
        new_value = b"foobar"
        result = test_app.put(headers={"If-Match": etag}, data=new_value)
        self.assertEqual(200, result.status_code)
        self.assertEqual(new_value, result.data)

    def test_put_index_if_match_negative(self):
        test_app = app.test_client()
        result = test_app.put(headers={"If-Match": "wrong"})
        self.assertEqual(412, result.status_code)


if __name__ == "__main__":
    app.run()

"""
As you can easily spot in the unit tests I have included, it is easy for a 
client to check that the resource has not been modified before overwriting it: 
if the data has changed, then the ETag is going to be different than the one 
included in If-Matches, and therefore, the request is aborted with a 412 
Precondition Failed status code being returned. The client can then issue a 
new GET / request to retrieve the new content and ETag, redo any computation 
it wants to do, and try again to update it. The code shown in the client.py in 
the above application implements such a retry loop that implements this optimistic 
concurrency model.

In the above application, open another terminal and enter command 
cd /examples/building-rest-api to move to the relevant directory. Then, run 
command python client.py to invoke the client.

Note: As you may have noticed, there is no delay between each retry implemented 
in the example from client.py. Hammering the HTTP endpoint is not a very good 
practice, as it can overload the HTTP server easily until a client wins the race. 
Since this case is a (soft) failure scenario, the correct strategies to implement 
in order to retry correctly on failure are described in Designing for Failure.

Using ETag header is a great way to implement basic concurrency control on your 
HTTP API while also providing hints for clients to cache data as needed. 
It improves scalability by reducing the network traffic and CPU usage of your 
application, and moreover it allows consumers to work on the same data without 
conflicting with each other.

"""
